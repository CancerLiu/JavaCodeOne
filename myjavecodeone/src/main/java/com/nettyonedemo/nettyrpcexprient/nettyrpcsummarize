

    首先这是一个使用Netty写的RPC框架，大致分为5部分(5个包)，依次为共用部分(用于RPC客户端和服务器端序列化和反序列化使用);核心业务逻辑处理器部分;服务器端部分;客户端部分;
启动部分;

    (1)公共部分是客户端与服务器端都通用的东西，即此处客户端计算输入的参数与服务器端计算输出的参数分别封装成了两个对象;
    (2)处理器类实际上就是ChannelHandler，只不过是业务紧密相关的，用于服务器端调用根据输入参数来计算结果;这部分自定义的ChannelHandler会最终在服务器端的总ChannelHandler
中(即MessageServerChannel类中)被调用。所以此处的处理器类似于将核心计算逻辑进行了抽象;
    (3)接下来是服务器端。服务器端依功能来说，有以下几个部分:
    ①抽象出的核心业务逻辑处理器类，都是IMessageHandler的实现类，共三个(DefaultHandler、ExpRequestHandler、FibRequestHandler——其中两个在处理器包中);
    ②编、解码器各一个，用于解析或者编码Netty中的字节对象,然后封装成对象;
    ③注册类，共两个，分别用于将特定的类型和相应的处理器绑定在一起，将特定的类型和相应的用于序列化和反序列化的类型绑定
    ④消息封装类(在客户端和服务器端都有类似属性结构的对象，用于对原始的字节进行封装)，编、解码后以该对象类为统一的输入输出口径;对象有三个属性，依次为id(用于客户端得到
    相应的数据，避免数据混淆),type(类型，注册的时候使用),payload(实际的数据);
    ⑤业务ChannelHandler类，用于拦截并处理一些消息;
    ⑥服务器端主类(RPCServer),主要用于向服务器传入相应的参数，其中两个是IO线程数和业务线程数，前者由Netty自己管理，后者由该RPC框架本身管理
    (4)客户端类，很简单，没有使用NIO，也没有使用Netty，直接使用的常规的BIO，向服务器端发送数据;